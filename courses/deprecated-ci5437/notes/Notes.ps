%!PS-Adobe-3.0
%%Title: stdin
%%For: Blai Bonet
%%Creator: a2ps version 4.14
%%CreationDate: Thu Jun  5 13:30:59 2014
%%BoundingBox: 24 24 588 768
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 13
%%PageOrder: Ascend
%%DocumentMedia: Letter 612 792 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontMatrix get 3 get 1000 mul
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      % <vector> <key> <val>
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def % -

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Get the underline position and thickness if they're defined.
    % Use 1 if they are not defined.
    currentdict /FontInfo 2 copy known
    { get
      /UnderlinePosition 2 copy % <FontInfo> /UP <FontInfo> /UP
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>

      /UnderlineThickness 2 copy % <FontInfo> /UT <FontInfo> /UT
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>
      pop % -
    }{ pop pop
    } ifelse

    currentdict
  end 
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 612 def
/sw 792 def
/llx 24 def
/urx 768 def
/ury 588 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 7.493857 def
/cw 4.496314 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   522.321860 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(=====================================================================) p n
(I. Presentacion del curso) N
(=====================================================================) N
() N
(Evaluacion:) N
(  3 mini proyectos y proyecto final de 50%,) N
(  Examen de 50%.) N
(  Grupos de 3 personas.) N
() N
(Horas de consulta:) N
(  Acercarse a la oficina, con o sin cita.) N
() N
(Alcance y objetivos del curso. Temas:) N
(  Busqueda:) N
(    Busqueda heuristica en grafos OR:) N
(      BFS, DFS, DFID, A*, IDA*, LRTA*, Branch and bound) N
(      ) N
(    Descomposicion de problemas:) N
(      Grafos AND/OR) N
(      AO*) N
(      Ciclos) N
(      LDFS) N
() N
(    Arboles de Juego) N
(      Minmax) N
(      Alpha-beta prunning) N
(      Scout, MTD) N
(      UCT) N
() N
(  Planificacion Automatica) N
(    STRIPS y SAS+) N
(    \(Ver libro\)) N
() N
(  CSPs) N
(    Varios algoritmos y tecnicas) N
(    Nociones de consistencia) N
(    Treewidth, strong consistency, backtrack-free search) N
() N
(  Rep. conocimiento e inferencia en logica:) N
(    Logica Proposicional:) N
(      CNF, Complejidad, 2CNF) N
(      DPLL, Clause Learning) N
(      Caso de Estudio: Planificacion via SAT) N
() N
(    Logica de Primer Orden) N
(      Forma Clausal, Resolucion) N
() N
(  Manejo de Incertidumbre) N
(    Representacion e inferencia:) N
(      Markov Networks) N
(      Redes Bayesianas) N
(      Factor Graphs) N
() N
(---------------------------------------------------------------------) N
() N
(?Que es la I.A.?) N
(  Un poco de historia) N
(  Overview of subfields including) N
(    Vision vs computacion grafica) N
(    NLP vs speech generation) N
(    Busqueda & Planning) N
(    Machine learning) N
(    etc) N
() N
(Lenguajes de programacion) N
(  Lisp, Scheme precursores de programacion funcional) N
(  Prolog) N
(  Dedicados como sistemas expertos \(rules\), CP y otros) N
(  Generales por motivos de eficiencia: C/C++, Java, Python, etc.) N
(stdin) (Page 1/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(---------------------------------------------------------------------) N
() N
(Busqueda:) N
() N
(  Espacio de busqueda caracterizado por:) N
(    - conjunto finito de estados) N
(    - estado inicial s_0) N
(    - estados objetivos G) N
(    - operadores de transicion \(acciones\) A, y A\(s\)) N
(    - funcion de transicion f\(s,a\)) N
(    - funcion de costo c\(s,a\)) N
() N
(  Representacion:) N
(    explicita \(mat. incidencia/lista adyacencia\) vs implicita) N
() N
(  Ejemplo: agent que navega en grid n x m) N
() N
(  Soluciones: que es solucion, que es solucion optima.) N
() N
(  Otros ejemplos:) N
(    8-puzzle, 15-puzzle, 24-puzzle, \(n^2 - 1\)-puzzle, \(nm - 1\)-puzzle) N
(    Cubo de Rubik) N
(    Torres de Hanoi con 4 astas) N
() N
(  Nociones fundamentales:) N
(    - estados vs nodos que representan estados) N
(    - duplicados) N
(    - arbol de busqueda: ciclos de estados generan arboles infinitos) N
(    - generar: estado se genera cuando se crea un nodo que lo representa) N
(    - expandir: estado se expande cuando se generan todos sus sucesores) N
() N
(  Algoritmos: BFS, DFS, DFID, A*, IDA*, LRTA*, BnB) N
() N
(  Dimensiones de analisis:) N
(    completitud, optimalidad, complejidad tiempo y espacio) N
() N
(=====================================================================) N
(II. Busqueda: preliminares, BFS, DFS y DFID.) N
(=====================================================================) N
() N
(?Que contiene un node en el arbol de busqueda?) N
() N
(Cada nodo en el arbol de busqueda representa un estado) N
(en el espacio de busqueda mas informacion acerca de donde,) N
(cuando y como los estados son encontrados durante la busqueda. ) N
() N
(Todo nodo n tiene asociado:) N
() N
(state\(n\) = estado representado por n) N
(parent\(n\) = pointer al nodo desde el cual n es alcanzado) N
(action\(n\) = accion que mapea state\(parent\(n\)\) en state\(n\)) N
(g\(n\) = cost del camino representado por n) N
() N
(Los algoritmos de busqueda utilizan las siguientes operaciones) N
(sobre estados:) N
() N
(- init\(\) que genera el estado inicial) N
(- is-goal\(s\) que prueba si s es un estado objetivo) N
(- succ\(s\) genera una lista de estados sucesores de s junto) N
(  con las acciones que los alcanzan. La lista es una lista ) N
(  de pares <o,s> donde o es una accion \(op.\) y s un estado.) N
() N
(y las siguientes operaciones sobre nodos:) N
() N
(- make-root-node\(s\) construye un nodo raiz del arbol de busqueda) N
(  que representa al estado dado:) N
() N
(  make-root-node\(s\):) N
(stdin) (Page 2/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (1/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    n := new node) p n
(    state\(n\) := s) N
(    parent\(n\) := null) N
(    action\(n\) := null) N
(    g\(n\) := 0) N
(    return n) N
() N
(- make-node\(n,a,s\): construye un nodo que representa al estado) N
(  s dado generado por la accion a aplicada en state\(n\)) N
() N
(  make-node\(n,a,s\):) N
(    n' := new node) N
(    state\(n'\) := s) N
(    parent\(n'\) := n) N
(    action\(n'\) := a) N
(    g\(n'\) := g\(n\) + cost\(state\(n\),a\)) N
() N
(- extract-solution\(n\): extrae el camino que conlleva al nodo n) N
() N
(  extract-solution\(n\):) N
(    solution := new list) N
(    while parent\(n\) != null do) N
(        solution.push-front\(action\(n\)\)) N
(        n := parent\(n\)) N
(    return solution) N
(  ) N
(---------------------------------------------------------------------) N
() N
(Breadth-First Search \(busqueda en amplitud\)) N
() N
(  Esquema general sin/con eliminacion de duplicados) N
() N
(  BFS \(sin eliminacion de duplicados\)) N
(  -----------------------------------) N
(  queue := new fifo-queue) N
(  queue.push-back\(make-root-node\(init\(\)\)\)) N
(  while !queue.empty\(\) do) N
(      n := queue.pop-front\(\)) N
(      if is-goal\(state\(n\)\) then) N
(          return extract-solution\(n\)) N
(      for each <o,s> in succ\(state\(n\)\) do) N
(          n' := make-node\(n,o,s\)) N
(          queue.push-back\(n'\)) N
(      return UNVOLSABLE) N
() N
(  Mejoras posibles:) N
(    Eliminacion de duplicados) N
(    Chequear por goal al momento de generacion) N
() N
(  BFS \(con eliminacion de duplicados\)) N
(  -----------------------------------) N
(  queue := new fifo-queue) N
(  queue.push-back\(make-root-node\(init\(\)\)\)) N
(  closed := emptyset) N
(  while !queue.empty\(\) do) N
(      n = queue.pop-front\(\)) N
(      if state\(n\) isn't in closed, then) N
(          closed.insert\(state\(n\)\)) N
(          if is-goal\(state\(n\)\) then) N
(              return extract-solution\(n\)) N
(          for each <o,s> in succ\(state\(n\)\) do) N
(              n' := make-node\(n,o,s\)) N
(              queue.push-back\(n'\)) N
(  return UNVOLSABLE) N
() N
(  Analisis) N
(  --------) N
(  Completitud: Suponga que existe un estado objetivo en el espacio de) N
(  busqueda. Sea \\pi un camino desde el estado inicial a un estado goal.) N
(stdin) (Page 3/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(  Invariante-1: siempre existe un nodo n en queue tal que state\(n\)) N
(  aparece en \\pi y state\(n\) isn't closed \(para BFS con elim. de dup.\)) N
() N
(  Dem: por induccion en el numero de iteraciones del lazo. Al comienzo) N
(  el invariante es cierto ya que queue solo contiene el estado inicial.) N
(  Suponga que el invariante es cierto al inicio del ciclo. Si el invariante) N
(  se cumple para un nodo n' en queue distinto del nodo seleccionado n,) N
(  entonces el invariante se sigue cumpliendo al inicio de la proxima) N
(  iteracion. Consideramos los dos algoritmos de BFS.) N
() N
(  BFS sin eliminacion de duplicados. Si state\(n\) es goal, entonces) N
(  el algoritmo termina. Sino, todos los sucesores de state\(n\) son) N
(  generados e insertados en queue. Por lo tanto, el sucesor de) N
(  state\(n\) en \\pi es insertado en queue, y el invariante se cumple) N
(  al inicio de la proxima iteracion.) N
() N
(  BFS con eliminacion de duplicados. Por definicion del invariante,) N
(  state\(n\) no esta closed ya que por hipotesis n es el unico nodo) N
(  que satisface el invariante. Si state\(n\) es goal, el algoritmo) N
(  termina. Sino, todos sus hijos son generados e insertados en queue.) N
(  Tenemos que mostrar que despues de las inserciones, el invariante) N
(  se cumple. ... TODO) N
() N
(  Consecuencia: BFS \(con/sin eliminacion de duplicados\) es completo.) N
() N
(  Optimalidad: BFS consigue un camino de menor numero de pasos \(no) N
(  necesariamente de menor costo\), si dicho camino existe.) N
() N
(  Invariante 2: los estados en queue estan ordenados por la distancia) N
(  al node raiz. Mas aun, la cola solo contiene estados a distancia) N
(  n o n+1 de la raiz, para algun n.) N
() N
(  Dem: TODO) N
() N
(  Demostracion de optimalidad por reduccion al absurdo. Suponga que) N
(  BFS consigue un camino que no es de menor longitud. Al momento de) N
(  terminar, se ha extraido un nodo n de queue \(un nodo goal\) tal que) N
(  su costo es mayor al costo del camino optimo. Por Inv-1, en queue) N
(  hay un nodo n' en el camino optimo. Por lo tanto, g\(n'\) < g\(n\).) N
(  Por Inv-2, n' se debio extraer antes que n.) N
() N
(  Para analisis de tiempo y espacio. Asuma un arbol de busqueda ) N
(  regular con factor de ramificacion b y donde el primer objetivo) N
(  encontrado esta a profundidad d.) N
() N
(  Analisis de Tiempo: O\(b^d\)) N
() N
(  Analisis de Espacio: O\(b^d\)) N
() N
(---------------------------------------------------------------------) N
() N
(Depth-First Search \(busqueda en profundidad\)) N
() N
(  DFS \(recursivo\)) N
(  ---------------) N
(  n := make-root-node\(init\(\)\)) N
(  <plan,cost> := DFS-Search\(n, 0\)) N
(  return plan) N
() N
(  DFS-Search\(node n, int g\)) N
(  -------------------------) N
(  if is-goal\(state\(n\)\) then return <extract-solution\(n\), g>) N
(  for each <a,s> in succ\(state\(n\)\) do) N
(      <plan,cost> := DFS-Search\(make-node\(n,o,s\), g + cost\(state\(n\),a\)) N
(      if plan != null then return <plan,cost>) N
(  return <null, infty>) N
() N
(  Analisis: incompleto, tiempo = O\(b^d\), espacio = O\(bd\)) N
(stdin) (Page 4/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (2/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(Depth-First Iterative Deepening \(DFID\)) N
() N
(  DFID \(recursivo\)) N
(  ----------------) N
(  n := make-root\(init\(\)\)) N
(  t := 0) N
(  plan := null) N
(  while plan == null do) N
(      <plan,cost> := Depth-Bounded-DFS\(n, 0, t\)) N
(      if plan != null then return plan) N
(      t := cost) N
(  return null) N
() N
(  Depth-Bounded-DFS\(node n, int g, int t\)) N
(  ---------------------------------------) N
(  if g > t then return <null,g>) N
(  if is-goal\(state\(n\)\) then return <extract-solution\(n\), g>) N
() N
(  new-t := infty) N
(  for each <a,s> in succ\(state\(n\)\) do) N
(      <plan,cost> := Depth-Bounded-DFS\(make-node\(n,a,s\), t, g + cost\(state\(n\),a\)) N
(\)) N
(      if plan != null then return <plan,cost>) N
(      new-t := min\(new-t, cost\)) N
(  return <null, new-t>) N
() N
(  Analisis: completo, optimo para funcion de costo uniforme, ) N
(  tiempo = O\(b^d\), espacio = O\(bd\)) N
() N
(=====================================================================) N
(III. Busqueda: UCS, Best-First Search y A*) N
(=====================================================================) N
() N
(Uniform-cost Search: best-first search c/ eliminacion duplicados) N
() N
(  UCS \(con eliminacion de duplicados\)) N
(  -----------------------------------) N
(  queue := new priority-queue \(sorted by g-value\)) N
(  queue.insert\(make-root-node\(init\(\)\)\)) N
(  closed := emptyset) N
(  while !queue.empty\(\) do) N
(      n = queue.pop-first\(\)) N
(      if state\(n\) isn't in closed, then) N
(          closed.insert\(state\(n\)\)) N
(          if is-goal\(state\(n\)\) then) N
(              return extract-solution\(n\)) N
(          for each <o,s> in succ\(state\(n\)\) do) N
(              n' = make-node\(n,o,s\)) N
(              queue.push-back\(n'\)) N
(  return UNVOLSABLE) N
() N
(Analisis: complete, optimal, tiempo y espacio O\(b^n\)) N
() N
(---------------------------------------------------------------------) N
() N
(Busqueda con heuristicas:) N
() N
(Heuristica h\(.\) es funcion sobre estados que "estima" el costo del) N
(camino de menor costo desde un estado dado a un goal. Las heuristicas) N
(se aplican sobre nodos n, como h\(n\)=h\(state\(n\)\), y si queremos ser) N
(mas generales, se pueden definir directamente sobre los nodos) N
() N
(Estimacion de la distancias:) N
() N
(1. For most heuristic search algorithms, h does not need to) N
(   have any strong properties for the algorithm to be correct) N
(   or complete,) N
() N
(stdin) (Page 5/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(2. However, the efficiency of the algorithm closely relates) p n
(   to how accurately h reflects the actual goal distance.) N
() N
(3. For some algorithms, like A*, we can prove strong formal) N
(   relationships between properties of h and properties of the) N
(   algorithm \(optimality, dominance, run-time for bounded error,) N
(   etc\)) N
() N
(4. For other search algorithms, "it works well in practice" is) N
(   often as good an analysis as one gets.) N
() N
(Propiedades:) N
() N
(A heuristic h is called:) N
() N
(1. safe \(segura\) if h*\(n\)=infty for all n with h\(n\)=infty) N
(2. goal-aware \(reconoce el goal\) if h\(n\)=0 for all goal nodes n) N
(3. admissible if h\(n\) <= h*\(n\) for all nodes n) N
(4. consistent if h\(n\) <= h\(n'\) + c\(state\(n\),a\) for all ) N
(   nodes n, n' such that <a,state\(n'\)> in succ\(state\(n\)\)) N
() N
(Implicaciones: \(4\) => \(3\) => \(1\)) N
() N
(Heuristica Perfecta h*:) N
() N
(The optimal or perfect heuristic of a search space is the) N
(heuristic h* which maps each search node n to the length of a) N
(shortest path from state\(n\) to any goal state. Note: h*\(n\) ) N
(equals infinity iff no goal state is reachable from n.) N
() N
() N
(---------------------------------------------------------------------) N
() N
(Idea: utilizar la heuristica h\(.\) p/ seleccionar proximo nodo) N
(      a expandir. Resultado: Greedy Best-First Search) N
() N
() N
(  GBFS \(con eliminacion de duplicados\)) N
(  -----------------------------------) N
(  queue := new priority-queue sorted by h-value) N
(  queue.insert\(make-root-node\(init\(\)\)\)) N
(  closed := emptyset) N
(  while !queue.empty\(\) do) N
(      n = queue.pop-first\(\)) N
(      if state\(n\) isn't in closed, then) N
(          closed.insert\(state\(n\)\)) N
(          if is-goal\(state\(n\)\) then) N
(              return extract-solution\(n\)) N
(          for each <o,s> in succ\(state\(n\)\) do) N
(              n' = make-node\(n,o,s\)) N
(              if h\(n'\) < infty:) N
(                  queue.push-back\(n'\)) N
(  return UNVOLSABLE) N
() N
(Analisis: completo \(para h segura por deteccion de duplicados\), suboptimo,) N
(          tiempo y espacio igual a BFS \(para h=0\)) N
() N
(---------------------------------------------------------------------) N
() N
(Como incorporar la heuristica en un algoritmo que sea completo) N
(y optimo? Respuesta: Best-First Search.) N
() N
(  BFS \(con eliminacion de duplicados\)) N
(  -----------------------------------) N
(  queue := new priority-queue sorted by g+h-value) N
(  queue.insert\(make-root-node\(init\(\)\)\)) N
(  closed := emptyset) N
(  while !queue.empty\(\) do) N
(      n = queue.pop-first\(\)) N
(stdin) (Page 6/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (3/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      if state\(n\) isn't in closed or g\(n\) < distance\(state\(n\)\), then) p n
(          closed.insert\(state\(n\)\)) N
(          distance\(state\(n\)\) = g\(n\)) N
(          if is-goal\(state\(n\)\) then) N
(              return extract-solution\(n\)) N
(          for each <o,s> in succ\(state\(n\)\) do) N
(              n' = make-node\(n,o,s\)) N
(              if h\(n'\) < infty:) N
(                  queue.push-back\(n'\)) N
(  return UNVOLSABLE) N
() N
(Nota: Cuando el node n se expande aun cuando state\(n\) esta cerrado \(porque) N
(      g\(n\) < distance\(state\(n\)\)\), se dice que el estado state\(n\) se re-abrio.) N
() N
(El valor f de un nodo n es f\(n\) = g\(n\) + h\(n\)) N
() N
(Analisis:) N
() N
(1. Completo para h segura \(aun sin eliminacion de duplicados\)) N
(2. Optimo si h es admissible) N
(3. Nunca re-abre un nodo si h es consistente) N
(4. Tiempo / espacio en peor caso igual a UCS \(caso h=0\)) N
() N
(Implementacion:) N
(    ) N
(1. In the heap-ordering procedure, it is considered a good) N
(   idea to break ties in favour of lower h values) N
() N
(2. Can simplify algorithm if we know that we only have to) N
(   deal with consistent heuristics) N
() N
(3. Common, hard to spot bug: test membership in closed at) N
(   the wrong time) N
() N
() N
(Ejemplo: 15-puzzle, Manhattan distance: def, prop., computo) N
() N
(=====================================================================) N
(IV. Busqueda: Weighted A*, IDA*, HC y EHC) N
(=====================================================================) N
() N
(Weighted A*: igual a A* pero con la heuristica multiplicada por ) N
(             constante W) N
() N
(Rol de W:) N
() N
(1. Para W=0, se convierte en UCS) N
(2. Para W=1, se convierte en A*) N
(3. Para W -> infty, se convierte en Greedy Best-First Search) N
() N
(Propiedad:) N
() N
(For W > 1, can prove similar properties to A* , replacing) N
(optimal with bounded suboptimal: generated solutions are) N
(at most a factor W as costly as the optimal ones.) N
() N
(---------------------------------------------------------------------) N
() N
(Linear-space A* = IDA*) N
() N
(DFID es para BFS lo que IDA* es para A*.) N
() N
() N
(  IDA* w/ heuristic h) N
(  -------------------) N
(  n := make-root-node\(init\(\)\)) N
(  t := f\(n\) [= h\(n\)]) N
(  plan := null) N
(  while plan == null do) N
(stdin) (Page 7/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      <plan, cost> := Bounded-DFS\(n,t,0\)) p n
(      if cost == infty then return null) N
(      t := cost) N
(  return plan) N
() N
() N
(  Bounded-DFS\(node n, int t, int g\)) N
(  ---------------------------------) N
(  f := g + h\(n\)) N
(  if f > t then return <null, f>) N
(  if is-goal\(state\(n\)\) then return <extract-solution\(n\), g>) N
() N
(  new-t := infty) N
(  for each <a,s> in succ\(state\(n\)\) do) N
(      <plan, cost> := Bounded-DFS\(make-node\(n,a,s\), t, g + cost\(s,a\)\)) N
(      if plan != null return <plan, cost>) N
(      new-t := min\(new-t, cost\)) N
(  return <null, new-t>) N
() N
() N
(---------------------------------------------------------------------) N
() N
(Other algorithms for finding quick solutions: Hill-Climbing and) N
(Enforced Hill-Climbing) N
() N
(  Hill-Climbing) N
(  -------------) N
(  n := make-root-node\(init\(\)\)) N
(  while true do) N
(      if is-goal\(state\(n\)\) then return extract-solution\(n\)) N
(      Succ := { make-node\(n,a,s\) : <a,s> in succ\(state\(n\)\) }) N
(      n := extract node from Succ minimizing h \(random-tie breaking\)) N
() N
(  Properties:) N
() N
(  1. Different from GBS as GBS select the best in queue with evaluation) N
(     function f\(n\) = h\(n\), while HC selects the best child.) N
() N
(  2. Can get stuck in cycle or local minima) N
() N
(  3. Many variations including tie-breaking strategies, restarts, etc) N
() N
(  Variation: Enforced Hill-Climbing: procedure improve make a breadth-first) N
(  search to find a more promising node than n0) N
() N
(  Improve\(n0\)) N
(  -----------) N
(  queue := new fifo-queue) N
(  queue.push\(n0\)) N
(  closed := emptyset) N
(  while !queue.empty\(\) do) N
(      n := queue.pop-first\(\)) N
(      if state\(n\) isn't in closed then) N
(          closed.insert\(state\(n\)\)) N
(          if h\(n\) < h\(n0\) then return n) N
(          for each <a,s> in succ\(state\(n\)\) do) N
(              n' := make-node\(n,a,s\)) N
(              queue.push-back\(n'\)) N
(  return null) N
() N
(  Enforced Hill-Climbing) N
(  ----------------------) N
(  n := make-root-node\(init\(\)\)) N
(  while n != null and !is-goal\(state\(n\)\) then) N
(      n := Improve\(n\)) N
(  return n == null ? null : extract-solution\(n\)) N
() N
(  Properties:) N
() N
(stdin) (Page 8/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (4/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  1. a very popular algorithm when one just wants a solution and) p n
(     have a reasonable heuristic) N
() N
(  2. improve can fail due to either there is no solution from n0) N
(     \(dead end\) or run out of memory) N
() N
(  3. complete for undirected search spaces \(where the successor) N
(     relation in symmetric\) if h\(n\) = 0 for all and only goal nodes) N
() N
() N
(=====================================================================) N
(V. Busqueda: Branch-and-Bound, LRTA*. Heuristicias) N
(=====================================================================) N
() N
(  Branch-and-bound) N
(  -----------------) N
(  alpha := infty) N
(  best-leaf := null) N
(  DFS-BnB\(make-root-node\(init\(\)\)\)) N
(  return <extract-solution\(best-leaf\),alpha>) N
() N
(  DFS-BnB\(n\)) N
(  ----------) N
(  if f\(n\) > alpha then return null) N
(  if is-leaf\(n\) then) N
(      if g\(n\) < alpha then) N
(          best-leaf := n) N
(          alpha := g\(n\)) N
(      end if) N
(  end if) N
() N
(  for each <a,s> in succ\(state\(n\)\) do) N
(      DFS-BnB\(make-node\(n,a,s\)\)) N
() N
(  Works for problems in which all solutions appear as leafs of the tree) N
(  and there are no infinite branches) N
() N
(  Analisis: completo, optimo, linear space, exponential time) N
() N
(  Heavily used in some combinatoria problems such as TSP,) N
(  some cases can deliver best performance than IDA*) N
() N
(---------------------------------------------------------------------) N
() N
(  Real-Time Search) N
(  ----------------) N
() N
(  Setting: agent acting \(moving\) in a real or simulated environment) N
(  that wants to reach a goal state. Interleaves "planning" and execution.) N
(  Assume that the environment is safely explorable.) N
() N
(  Maintains a global hash table that is used to store values associated) N
(  with nodes that are updates each time the agent makes a decision.) N
() N
(  LRTA* stands for "Learning Real-Time Search") N
() N
(  LRTA*) N
(  -----) N
(  n := make-root-node\(init\(\)\)) N
(  repeat) N
(    LRTA*-Trial\(n\)) N
(  until [some condition]) N
() N
(  LRTA*-Trial\(n\)) N
(  --------------) N
(  while !is-goal\(n\) do) N
(      for each <a,s> in succ\(state\(n\)\) do) N
(          next[a] := s) N
(          Q\(state\(n\),a\) := c\(state\(n\),a\) + H\(s\)) N
(stdin) (Page 9/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      Select a* as action a minimizing Q\(state\(n\),a\)) p n
(      Update H\(state\(n\)\) := Q\(state\(n\),a*\)) N
(      Set n := make-node\(n,a*,next[a*]\)) N
() N
(  H\(.\) is a hash table that is initially empty. When fetching a value) N
(  for s, if H\(s\) does not contain an entry for s, the value h\(s\) is) N
(  returned, else H\(s\) is returned. when updating H\(s\), if H contains) N
(  a entry for s, the value of the entry is changed. Otherwise, an) N
(  entry for s is allocated and initialized to the value.) N
() N
(  Properties: on safely explorable environments, each LRTA* trial) N
(  terminates in finite time, and the values in the hash table ) N
(  eventually converge. If, in addition, h is admissible, the  value) N
(  for the "relevant states" converge to their optimal values, and) N
(  the trials eventually "behave" optimal.) N
() N
(---------------------------------------------------------------------) N
() N
(  ?De donde vienen las heuristicas?) N
() N
(  Relajaciones del problema que pueden resolverse rapidamente:) N
(  polinomialmente \(en teoria\), linealmente o cuadraticamente \(practica\)) N
() N
(  Ejemplo: 15-puzzle) N
(  ------------------) N
() N
(  Admisible porque Manhattan distance is lower bound on *total*) N
(  number of movements that each tile must move. Also, cast it as) N
(  a relaxation where the tiles can move over each other.) N
() N
(  Abstraction heuristics) N
(  -----------------------) N
() N
(  Create abstraction either by collapsing nodes, reducing costs,) N
(  or adding edges \(shortcuts\). Abstractions can be either implicit) N
(  or explicit, and solved off-line or on-line. ) N
() N
(  A special type of abstraction, pattern database, is an explicit) N
(  and off-line heuristic that had been quite successful.) N
() N
(  Pattern Databases) N
(  -----------------) N
() N
(  Example: 15-puzzle: definition, how to compute it, etc.) N
(  ) N
(=====================================================================) N
(VI. Descomposicion de problemas. AO*.) N
(=====================================================================) N
() N
(Descomposicion de problemas:) N
() N
(Frecuentemente, un problema se descompone en subproblemas) N
(que tienen que resolverse. Tipico de problemas que pueden) N
(ser resueltos por estrategias divide-and-conquer. Las) N
(dependencias entre problemas y subproblemas pueden) N
(representarse como un arbol AND/OR.) N
() N
(Ejemplo: Torres de Hanoi con 3 postes) N
() N
(Move\(1..n,1,3\) decomposes into) N
(    Move\(1..n-1,1,2\) & Move\(n,1,3\) & Move\(1..n-1,2,3\)) N
() N
(Move\(1..n-1,1,2\) decomposes into) N
(    Move\(1..n-2,1,3\) & Move\(n-1,1,2\) & Move\(1..n-2,3,2\)) N
() N
(...) N
() N
(Ejemplo: Find path from a to z in graph \(not shown\)) N
() N
(stdin) (Page 10/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (5/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(Path\(a->z\):) p n
(    Path\(a->z, f\)) N
(    Path\(a->z, g\)) N
() N
(Path\(a->z, f\):) N
(    Path\(a->f\) & Path\(f->z\)) N
() N
(Path\(a->z, g\):) N
(    Path\(a->g\) & Path\(g->z\)) N
() N
(...) N
() N
(---------------------------------------------------------------------) N
() N
(Arboles y Grafos AND/OR:) N
() N
(Dos tipos de nodos, cada cual representa una tarea a realizar) N
(pero dos descomposiciones distintas:) N
() N
(Node OR: representa una tarea que para realizarla se necesita) N
(primero realizar una de las tareas correspondientes a sus hijos.) N
(Este nodo representa una eleccion.) N
() N
(Nodo AND: representa una tarea que para realizarla se necesita) N
(primero realizar todas las tareas correspondientes a sus hijos.) N
(Este nodo no representa una eleccion.) N
() N
(Hojas \(terminales\): tareas atomicas que no se subdividen.) N
() N
(Ejemplos: Torres de Hanoi, Find path.) N
() N
(---------------------------------------------------------------------) N
() N
(Solucion de Arbol AND/OR T: subarbol tal que:) N
() N
(1\) tiene la raiz de T) N
() N
(2\) si tiene node OR X de T, tiene uno solo hijo de X \(la subtarea) N
(   seleccionada\)) N
() N
(3\) si tiene nodo AND X de T, tiene todos los hijos de X.) N
() N
(Para el costo de la solucion, pueden existir varios criterios:) N
() N
(1\) Suma de todos los costos de las aristas en T) N
(2\) Costo del camino de mayor costo en T) N
(3\) Costo Promedio sobre caminos) N
(4\) etc.) N
() N
(---------------------------------------------------------------------) N
() N
(Algoritmo AO*:) N
() N
(Algoritmo de busqueda heuristica tipo best-first que mantiene la) N
(mejor solucion parcial hasta un momento dado. Asume que el grafo) N
(AND/OR es implicito y mantienen una representacion explicita parcial) N
(del grafo implicito. La parte explicita se le llama la parte) N
("explicada" del grafo implicito.) N
() N
(Pseudocode for AO*) N
() N
(=====================================================================) N
(VII. Busqueda no-deterministica. Algoritmos.) N
(=====================================================================) N
() N
(Problemas de busqueda no-deterministicos. Modelo dado por:) N
() N
(1. Conunto finito de estados S) N
(2. Estado inicial s0 en S) N
(stdin) (Page 11/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(3. Estados objetivos S_G) p n
(4. Acciones A\(s\) applicables en c/ estado) N
(5. Funcion de transicion no deterministica F\(s,a\)) N
(6. Costos c\(s,a\)) N
() N
(Solucion: estrategia para llevar el estado s0 a un estado goal.) N
(No es una secuencia de acciones por las transiciones no-deterministas.) N
(Se necesita consideras acciones que son funciones de estados en) N
(acciones, llamadas politicas.) N
() N
(Ejemplo: navigation in grid w/ non-det actions. Depict policy in) N
(grid.) N
() N
(For policy pi, define its executions. Then, pi is strong solution) N
(or strong cyclic solution in terms of executions. Strong solution) N
(if all its executions end in a goal state. Strong cyclic if every) N
(execution that do not end in a goal state is unfair. An execution) N
(is unfair if there is a state s that appears infinitely often ) N
(in the execution and there is an outcome s' in F\(s,pi\(s\)\) that) N
(only appears a finite number of times in execution.) N
(Strong solutions can be assigned costs but not for strong cyclic) N
(solutions.) N
() N
(For policy pi, define equations for cost of pi \(plain and optimistic\).) N
(If pi is strong solution, then V^pi\(s0\)<infty.  If pi is strong-cylcic) N
(solution, V_min^pi\(s\) < infty for every state s reachable from s0) N
(using pi. This will help us to design algorithms. Likewise, define) N
(Bellman equations.) N
() N
(Problem can be mapped into an AND/OR graph \(that may contain cycles\).) N
(OR nodes for states s in S, and AND nodes \(s,a\) for s in S and) N
(a in A\(s\). Also, we can consider AND/OR graph of histories with) N
(OR nodes \(s0,s1,..,sn\) and AND nodes \(s0,...,sn,a\) for a in A\(sn\).) N
(Graph is acyclic and possibly infinite. However, if there is) N
(a strong solution, AO* finds it in finite time.) N
() N
(Alternatively, can solve Bellman equation and compute greedy policy.) N
() N
(For computing strong cyclic solutions, can use the optimistic) N
(Bellman equation. First, let S' = S and solve V_min for every) N
(state in S'. Then, remove from S' every s such that V_min\(s\)=infty) N
(and actions a in A\(s\) that lead to removed s'. Iterate until) N
(fix point is reached. If s0 is removed, then problem has no) N
(strong solution. Else, the policy greedy wrt to last value) N
(function is strong solution.) N
() N
(Finally, one can utilize more complex algorithms for cyclic) N
(AND/OR graphs that find best policy wrt expected cost, but) N
(this requires that the transition function F\(.,.\) to be) N
(extended w/ transition probabilities. More about this later.) N
() N
(=====================================================================) N
(VIII. Arboles de Juego. Valor. Minmax y alpha-beta pruning.) N
(=====================================================================) N
() N
(Modelo de arbol de juegos: juegos de 2 personas y suma cero,) N
(con informacion completa. Two types of nodes: MAX and MIN.) N
(In big games, the tree is pruned to certain level that may) N
(not be regular across the whole tree. The leaves are assigned) N
(a heuristic evaluation function that measures the merit of ) N
(the board configuration represented by the node. Then, an ) N
(algorithm that treat such values as the value for the game) N
(is applied to try to find a best movement.) N
() N
(The tree can be searched with minimax algorithm. Observing ) N
(that max\(a,b\) = -min\(-a,-b\). Minmax can be expressed as) N
(follows which is known as Negamax:) N
() N
(  minimax\(node, depth\)) N
(stdin) (Page 12/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (6/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (13-14) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    if node is a terminal or depth <= 0:) p n
(      return heuristic\(node\)) N
(    aplha := -infty) N
(    for child in node:) N
(        alpha := max\(alpha, -minimax\(child, depth-1\)\)) N
(    return alpha) N
() N
([Run minimax in example "AB_pruning.svg"] Show principal) N
(variation of the game, and that any deviation by one of) N
(the players from the PV is a suboptimal move.) N
() N
(Complexity of Minimax: O\(b^d\) but maybe far less if solution) N
(for subtrees are cached and reused.) N
() N
(Alpha-Beta Pruning) N
(------------------) N
(Alpha-beta pruning is an algorithm that seeks to decrease the number) N
(of nodes that are evaluated by the minimax algorithm. It stops) N
(completely evaluating a move when at least one possibility has been) N
(found that proves the move to be worse than a previously examined) N
(move. Such moves need not be evaluated further. When applied to a) N
(standard minimax tree, it returns the same move as minimax would,) N
(but prunes away branches that cannot possibly influence the final) N
(decision.) N
() N
(Diagram w/ motivation:) N
() N
(       [max]) N
(      /     \\) N
(     /       \\) N
(  \(min\)     \(min\)) N
(  alpha     /   \\) N
(           /     \\) N
(         beta   [pruned: if beta <= alpha]) N
() N
(This is a shallow cut-off but there may be other type of cut-offs,) N
(called deep cut-off.) N
() N
(  alphabeta\(node, depth, alpha, beta, Player\)         ) N
(    if depth = 0 or node is a terminal) N
(        return heuristic\(node\)) N
(    if Player = MaxPlayer) N
(      for each child of node) N
(        alpha := max\(alpha, alphabeta\(child, depth-1, alpha, beta, not\(Player\)\)\)) N
(        if alpha >= beta) N
(          break                             \(* Beta cut-off *\)) N
(      return alpha) N
(    else) N
(      for each child of node) N
(        beta := min\(beta, alphabeta\(child, depth-1, alpha, beta, not\(Player\)\)\)) N
(        if alpha >= beta) N
(          break                             \(* Alpha cut-off *\)) N
(      return beta) N
() N
(  \(* Initial call *\)) N
(  alphabeta\(origin, depth, -infinity, +infinity, MaxPlayer\)) N
() N
(With an \(average or constant\) branching factor of b, and a search) N
(depth of d plies, the maximum number of leaf node positions evaluated) N
(\(when the move ordering is pessimal\) is O\(b*b*...*b\) = O\(b^d\) \342M-^@M-^S the) N
(same as a simple minimax search. If the move ordering for the search) N
(is optimal \(meaning the best moves are always searched first\), the) N
(number of leaf node positions evaluated is about O\(b*1*b*1*...*b\)) N
(for odd depth and O\(b*1*b*1*...*1\) for even depth, or O\(b^{d/2}\) =) N
(O\(\\sqrt{b^d}\). In the latter case, where the ply of a search is even,) N
(the effective branching factor is reduced to its square root, or,) N
(equivalently, the search can go twice as deep with the same amount of) N
(computation. The explanation of b*1*b*1*... is that all the first player's) N
(moves must be studied to find the best one, but for each, only the best) N
(stdin) (Page 13/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(second player's move is needed to refute all but the first \(and best\)) p n
(first player move \342M-^@M-^S alpha-beta ensures no other second player moves) N
(need be considered. When nodes are ordered at random, the average number) N
(of nodes evaluated is roughly O\(b^{3d/4}\).) N
() N
(=====================================================================) N
(IX. Juegos. Algoritmos: Scout y Negascout.) N
(=====================================================================) N
() N
(Scout) N
() N
(Alpha-beta pruning seems the best that can be done. Can we do better?) N
() N
(Intuition: when in a Max node, suppose that we know a way for) N
(obtaining 300 points at the first branch. If there is an efficient) N
(way to know that the second branch yields at most 300 points,) N
(there is no need to search the second branch in *detail*.) N
() N
(It may be possible to verify whether the value of a branch is) N
(greater than a given value in a way that is faster than computing) N
(its exact value.) N
() N
(High-level idea:) N
() N
(- While searching a branch Tb of a Max node, if we have already) N
(  obtained a lower bound of v:) N
() N
(  First TEST whether it is possible for Tb to return something) N
(  better than v. If false, there is no need to search Tb, called) N
(  fail the test. If true, search Tb, called passes the test.) N
() N
(- While searching a branch Tb of a Min node, if we have already) N
(  obtained an upper bound v:) N
() N
(  First TEST whether it is possible for Tb to return something) N
(  better than v. If false, there is no need to search Tb, called) N
(  fail the test. If true, search Tb, called passes the test.) N
() N
(  Test\(node n, depth d, value v, condition >\)) N
(  if d == 0 or terminal\(n\) then return TRUE if h\(n\) > v, else FALSE) N
(  for n' in Succ\(n\) do) N
(    if n is Max and Test\(n', d-1, v, >\) is TRUE, return TRUE) N
(    if n is Min and Test\(n', d-1, v, >\) is FALSE, return FALSE) N
(  if n is Max, return FALSE, else return TRUE) N
() N
(  Algorithm Test can be adapted to change condition to >=, <, <=) N
() N
(  Scout\(n, depth d\)) N
(  if d == 0 or terminal\(n\) then return h\(n\)) N
(  Let n_1, n_2, ..., n_m be the successor of n) N
(  v := Scout\(n_1, d-1\)) N
(  for i = 2 to m do) N
(    if n is Max and Test\(n_i, v, >\) then v := Scout\(n_i\)) N
(    if n is Min and Test\(n_i, v, >=\) then v := Scout\(n_i\)) N
(  return v) N
() N
(Discussion of Scout) N
() N
(Test may visit less nodes than alpha-beta pruning [example]) N
(Scout may visit a node that is prune by alpha-beta) N
() N
(For Test to return TRUE at subtree T, it needs to evaluate) N
(at least: one child for a MAX node in T, all children for) N
(a MIN node in T. If T has fixed bf and uniform depth, the) N
(number of evaluated nodes is at least b^{d/2}) N
() N
(For Test to return FALSE at subtree T, it needs to evaluate) N
(at least: one child for a Min node in T, all children for) N
(a Max node in T. If T has fixed bf and uniform depth, the) N
(stdin) (Page 14/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (7/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (15-16) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(number of evaluated nodes is at least b^{d/2}) p n
() N
(A node may be visited more than once: one visit due to Test) N
(and other due to Scout.) N
() N
(Scout show great improvements for deep games with small) N
(branching factor. May be bad for games with large branching.) N
() N
(---------------------------------------------------------------------) N
(In an alpha-beta with window [alpha,beta]:) N
() N
(- Failed high means it return a value larger than beta) N
(- Failed low means it return a value smaller than alpha) N
(- Null or zero window is a window [m,m+1].) N
(  The result can be either:) N
() N
(  - Failed-high or m+1 meaning that the value is at >= m+1.) N
(    Equivalent to Test\(n,m,>\) is true.) N
() N
(  - Failed-low or m meaning that the value is at <= m.) N
(    Equivalent to Test\(n,m,>\) is false.) N
() N
(Alpha-beta + Scout) N
() N
(Intuition: try to put Scout and alpha-beta together. Search with) N
(null windows can be used as Test in Scout. Can also apply alpha-beta) N
(cutoffs if apply.) N
() N
(  [[GET SOURCE FOR NEGASCOUT FROM SLIDES]]) N
() N
(Negascout = Negamax + Scout) N
() N
(  [[GET SOURCE FOR NEGASCOUT FROM SLIDES]]) N
() N
(=====================================================================) N
(X. Planificacion.) N
(=====================================================================) N
() N
(Planificacion es "model-based approach to autonomous behaviour".) N
(A partir de una descripcion del problema que se quiere resolverm) N
(en donde se especifica en un lenguaje de alto nivel, la situacion) N
(initial, las situaciones objetivos, y las acciones aplicables, ) N
(un planificador debe encontrar una solucion, llamada plan, al) N
(problema. El planificador es entonces un solucionador general de) N
(problemas para una clase en particular de problems, aquellos que) N
(pueden ser expresados en el lenguaje.) N
() N
(    --- description ---> [PLANNER] --- solution --->) N
() N
(Planificacion clasica consiste en considerar problemas deterministicos) N
(con informacion completa. Existen varios lenguajes de descripcion de) N
(problemas, entre ellos STRIPS, ADL y SAS.) N
() N
(En STRIPS y ADL, una configuracion del mundo se codifica como una) N
(valuacion logica sobre un conjunto de proposiciones. Tipicamente, ) N
(un estado s se describe como el conjunto de las proposiciones que) N
(son asignadas por s el valor de verdad TRUE.) N
() N
(Ejemplo: Blocksworld: Descripcion de estados.) N
() N
(Los operadores en STRIPS corresponden a tripletas a=<P,A,D> de) N
(conjuntos de proposiciones.) N
() N
([[SEMANTICA DE STRIPS]]) N
() N
(Ejemplo: Blocksworld: Operadores.) N
() N
(ADL extiende a STRIPS permitiendo: precondiciones negativas,) N
(disjunciones en las precondiciones y efectos condicionales.) N
(stdin) (Page 15/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(Basta considerar precondiciones negativas y efectos condicionales.) p n
() N
(Compilar ADL into STRIPS: get rid of negative preconditions,) N
(and conditional effects.) N
() N
(SAS: lenguaje como generalizacion de STRIPS.) N
() N
([[Algo de COMPLEJIDAD]]) N
() N
(=====================================================================) N
(XI. Planificacion: Heuristicas.) N
(=====================================================================) N
() N
(Problemas de planificacion resueltos con algoritmos de ) N
(busqueda, que necesitan heuristicas. Las heuristicas ) N
(deben calcularse a partir de la descripcion del problema) N
(y deben funcionar para cualquier problema STRIPS.) N
() N
(Relajacion: h+. Propiedades importantes:) N
() N
(1. Basta applicar una accion a lo sumo una vez) N
(2. Planes cortos) N
(3. Scheduling is polynomial) N
(4. Decomposability of plans, exploited by heuristics) N
() N
(Heuristicas basicas: Additive y Max.) N
() N
(Equations based on states:) N
() N
(h\(s\) = h_add\(G;s\)) N
(h_add\(p;s\) = 0 if p in s; min_{a \\in O\(p\)} c\(a\) + h_add\(Pre\(a\);s\)) N
(h_add\(Pre\(a\);s\) = \\sum_{q\\in Pre\(a\)} h_add\(q;s\)) N
() N
(Can be computed in linear time. Max version is admissible) N
(and defined by the equation that results of replacing sum) N
(with max.) N
() N
([[GIVE PSEUDOCODE FOR h_add y h_max]]) N
() N
(---------------------------------------------------------------------) N
() N
(Relaxed plan heuristic.) N
() N
(Problem w/ h_add: double counting of actions, do not take into) N
(account side effects of actions. Can be fixed with Relaxed PG.) N
() N
(Layered fluent and action levels.) N
() N
(  P_0 = s) N
(  A_0 = { a : Pre\(a\) \\subseteq P_0 }) N
(  P_1 = P_0 \\cup { q \\in Add\(a\) | a \\in A_0 }) N
(  ...) N
(  A_k = { a : Pre\(a\) \\subseteq P_k }) N
(  P_{k+1} = P_k \\cup { q \\in Add\(a\) | a \\in A_k }) N
(  ...) N
() N
(Polynomial computation as there are at most |F| layers.) N
(From this, extract relaxed plan for G, starting from the) N
(first layer that contains G. If no such layer, problem ) N
(is not solvable. For each subgoal p at layer k, find ) N
(action at previous layer that add p and add preconditions) N
(of p as subgoals. Once the relaxed plan is computed,) N
(heuristic is number of action in it.) N
() N
([[GIVE PSEUDOCODE FOR h_FF]) N
() N
(Relaxed plan can be obtained w/ best supporters for h_max. Can) N
(be improved by considering best supporters for h_add.) N
() N
(stdin) (Page 16/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (8/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (17-18) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(=====================================================================) p n
(XI. CSPs.) N
(=====================================================================) N
() N
(Problem: assignment problem. Defined by variables, domains and ) N
(constraints. Task: find assignment that satisfy constraints.) N
(Formally, a CSP is made of variables X_i, domains D_i for each ) N
(variable X_i, constraints C_j. Each constraint C_j involves some) N
(subset of variables and specifies the *allowable* combinations) N
(of values.) N
() N
(A state is a \(partial\) assignment of values to variables. If it) N
(does not violate any constraint, the assignment is consistent.) N
(A consistent state that mention all variables is a solution.) N
() N
(Constraint Graph: Undirected graph. Nodes represent variables.) N
(Edge \(X,Y\) means that there is a constraint that mention both) N
(X and Y.) N
() N
(CSP can be formulated as a search problem, where) N
() N
(* Initial state is empty assignment) N
(* Successor function extends a partial assignment with X=x for) N
(    a variable X not mentioned in the assigment, provided that) N
(    the resulting assignment is consistent.) N
(* Goal states are complete assignments that, by previous case,) N
(    are consistent) N
(* Uniform costs equal to 1) N
() N
(Alternative formulation: states are complete assignments, not) N
(necessarily complete, and edges connect assignments \(e.g., ) N
(two assignments that differ in the value of just one variable\).) N
(This formulation used by local search methods.) N
() N
(Example: 8-Queens, Sudoku, Boolean CSPs \(made of boolean variables\),) N
(  cryptoarithmetic \(SEND + MORE = MONEY\), etc.) N
() N
(Type of constraints: unary, binary, higher order. Higher-order) N
(constraints can be converted into binary constraints by adding) N
(additional variables.) N
() N
(Naive branching: branching factor at top level is nd, at second) N
(level \(n-1\)d, etc. Total number of leaves is then n! * d^n, yet) N
(the different number of assignments is only d^n. Hence, there) N
(are a lot of duplicates and this branching is not good.) N
() N
(Problem: commutativity of assignments: X=1,Y=2 is equiv to Y=2,X=1.) N
() N
(Smart Branching: Given a node, the branches correspond to the) N
(different values for a fixed unassigned variable. The branching) N
(factor is thus only d. Since there are n variables, the number) N
(of leaves is d^n that equal the number of assignments.) N
() N
(Can be solved w/ simple depth-first backtracking algorithm:) N
() N
(  Recursive-Backtracking\(A, CSP\)) N
(    if A is complete, return A) N
(    var := select-unassigned-variable\(A, CSP\)) N
(    for each value in D_var do ) N
(        if var = value is consistent w/ A wrt CSP, then) N
(            A' := A union { var = value }) N
(            result := Recursive-Backtracking\(A', CSP\)) N
(            if result != FAIL, return result) N
(        end if) N
(    end for) N
(    return FAIL) N
() N
(Example: Australia map given by nodes {WA, NT, SA, Q, NSW, V, T}) N
(and edges:) N
(stdin) (Page 17/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
({ \(WA,NT\), \(WA,SA\), \(NT,SA\), \(NT,Q\), \(SA,Q\), \(SA,NSW\), \(SA,V\),) N
(  \(Q,NSW\), \(NSW,V\) }) N
() N
(Example of backtraking:) N
() N
(Critical issues when implementing solution:) N
() N
(1. Which variable should be chosen? How should its values be ordered?) N
() N
(2. What are the implications of current assignment for other unassigned) N
(   variables?) N
() N
(3. When a path fails, can the search avoid repeating the failure in) N
(   subsequent paths?) N
() N
(---------------------------------------------------------------------) N
() N
(Variable and Value ordering) N
() N
(Idea: choose the most constrained variable in order to detect a) N
(failure as soon as possible, because it is better to fail high) N
(on the tree than deep into it. Heuristic is called MRV \(Minimum) N
(Remaining Values\), Most Constrained Variable, or "fail-first".) N
() N
(Also, degree heuristics. Choose variable involved in most constraints.) N
(It can be used as a tie-breaker when using MRV.) N
() N
(Once variable is selected, its values must be ordered. Least-constraining) N
(value is an effective heuristic. It prefers values that rule out the) N
(fewest choices for the neighboring variables. Once the variable is) N
(fixed, try a value that will max the chances of finding a solution.) N
() N
(=====================================================================) N
(XI. CSPs.) N
(=====================================================================) N
() N
(Propagating Information through Constraints) N
() N
(Search space can be reduced by looking into the domain of variables) N
(before they are selected. This techniques can be implemented even) N
(before the search starts.) N
() N
() N
(Forward Checking) N
(----------------) N
() N
(Whenever a variable X is assigned, the FC process look at each unassigned) N
(variable Y that is connected to X by a constraint, and deletes from Y's) N
(domain any value that is inconsistent with the value chosen for X. Partner) N
(of the MRV heuristic: select the variable w/ current smallest domain.) N
() N
(Example 1:) N
([[Table de FC on Australia Map: order SA=R, .. \(choose vars using MRV\)]]) N
(                 WA   NT    Q  NSW    V   SA    T) N
(Initial         RGB  RGB  RGB  RGB  RGB  RGB  RGB) N
(After SA=R       GB   GB   GB   GB   GB  [R]  RGB) N
(After V=G        GB   GB   GB    B  [G]  [R]  RGB) N
(After NSW=B      GB   GB   G   [B]  [G]  [R]  RGB) N
(After Q=G        GB    B  [G]  [B]  [G]  [R]  RGB) N
(After NT=B       G   [B]  [G]  [B]  [G]  [R]  RGB) N
(After WA=G      [G]  [B]  [G]  [B]  [G]  [R]  RGB) N
(After T=R       [G]  [B]  [G]  [B]  [G]  [R]  [R]) N
() N
(Example 2:) N
([[Table de FC on Australia Map: order WA=R,Q=G,V=B]]) N
(                 WA   NT    Q  NSW    V   SA    T) N
(Initial         RGB  RGB  RGB  RGB  RGB  RGB  RGB) N
(After WA=R      [R]   GB  RGB  RGB  RGB   GB  RGB) N
(stdin) (Page 18/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (9/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (19-20) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(After Q=G       [R]    B  [G]  R B  RGB    B  RGB) p n
(After V=B       [R]    B  [G]  R    [B]   --  RGB) N
(Failure) N
() N
(In Example 2, FC is not able to detect an inconsistency right after) N
(the assignment Q=G, when the domains of the two connected vars) N
(NT and SA become equal to {B}. The reason for this is that FC only) N
(looks into neighbouring variables and not deep in the graph. This) N
(is solved with Arc Consistency.) N
() N
() N
(Arc Consistency) N
(---------------) N
() N
(  AC-3\(CSP\)) N
(  ---------) N
(  while Q is not empty do) N
(      \(X,Y\) := Q.first\(\)) N
(      if Remove-Inconsistent-Values\(X,Y\) then) N
(          for each Z in Neighbors[X] do) N
(              Q.add\(\(Z,X\)\)) N
(          end for) N
(      end if) N
(  end while) N
() N
(  Remove-Inconsistent-Values\(X,Y\)) N
(  -------------------------------) N
(  removed := false) N
(  for each x in Domain[X] do) N
(      if no value y in Domain[Y] satisfies the constraint between X and Y then) N
(          Remove x from Domain[X]) N
(          removed := true) N
(      end if) N
(  end for) N
(  return removed) N
() N
(  Time = O\(n^2d^3\) by bounding #insertions in queue) N
() N
(Higher-order Consistency) N
(------------------------) N
() N
(Path consistency: triplets of variables) N
(k-consistency: involving sets of k variables. Time = k-degree polynomial) N
() N
(CSP is strongly k-consistent iff it is j-consistent for j=1,..,k) N
() N
(Consistency can be enforced once, before search starts, or continuosly,) N
(each time that an assignment is done.) N
() N
(Enforcing k-consistency requires time O\(n^k\)) N
() N
(Algorithm: enforce n-consistency and solve it backtrack free. Explain) N
() N
() N
(Tree Structure) N
(--------------) N
() N
(If constraint graph is tree, CSP can be solved in quadratic time \(actually) N
(linear time\):) N
() N
(1\) Choose any variable as the root and order variables from the root) N
(to the leaves so that every node's parent in the tree precede it in ) N
(the ordering.) N
() N
(2\) Enforce arc consistency in all nodes \(it can be done better by enforcing) N
(directional arc consistency over selected edge directions, those appearing) N
(in the ordering computed in 1\).) N
() N
(3\) Assign values from first to last variable in the order backtrack free.) N
(stdin) (Page 19/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(General Graph Structure) N
(-----------------------) N
() N
(Two approaches:) N
() N
(  -- cutset conditionioning: find cutset that make graph tree and search) N
(     over all intantiations of cutset one that generates solution) N
() N
(  -- find an elimination order and enforce directional k-consistency along) N
(     the order. Then construct solution in a backtrack-free manner. The) N
(     k that is needed is equal to the width of elimination order which) N
(     is related to the treewidth of the graph. Explain treewidth.) N
() N
() N
(Example on Australia: solve in two ways.) N
() N
() N
(Backtracking: REVISE THIS) N
(------------) N
() N
(Consider the ordering and assignment {Q=R, NSW=G, V=B, T=R } ....) N
() N
(Conflict set for variable X is the set of previously assigned ) N
(variables that are connected to X. ) N
() N
(Backjumping = backtrack to the most recent variable in the conflict set.) N
() N
(FC can supply the conflict set without extra work. Whenever FC based) N
(on an assigment to X deletes a value from Y's domain, it should add ) N
(X to Y's conflict set. Also, every time the last value is deleted) N
(from Y's domain, the variables in the conflict set of Y are added) N
(to the conflict set of X. Then, when we get to Y, we know immediately) N
(where to backtrack if needed.) N
() N
(Summary:) N
() N
(Let Xj be current variable, and conf\(X_j\) its conflict set. If every) N
(possible value of Xj fails, backjump to the most recent variable Xi) N
(in conf\(X_j\) and set, Conf\(Xi\) := Conf\(Xi\) union Conf\(Xj\) - {Xi}.) N
() N
(Conflict-directed backtracking makes the right jump in the recursion,) N
(but does not avoid making the same mistake later in the search.) N
(Constraint learning adds new constraints that are induced by the) N
(discovered conflicts.) N
() N
() N
(stdin) (Page 20/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (10/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (21-22) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(=====================================================================) p n
(XII. SAT.) N
(=====================================================================) N
() N
([SAT-CNF. CNF vs. DNF. 2-CNF. Forma clausal. Condicionamiento.) N
(Condicionamiento en forma clausal.]) N
() N
(Running example:) N
() N
(Delta = {) N
(  1. {A,B}) N
(  2. {B,C}) N
(  3. {-A,-X,Y}) N
(  4. {-A,X,Z}) N
(  5. {-A,-Y,Z}) N
(  6. {-Z,X,-Z}) N
(  7. {-A,-Y,-Z} }) N
() N
() N
(Resolution: explain propositional resolution \(this also provides base) N
(for the later first-order resolution\). This is a rule of inference.) N
(This rule of inference is complete for propositional logic. Define) N
(resolution closure.) N
() N
(Unit resolution: explain unit resolution, its complexity and how it) N
(can be implemented efficiently. This is also a rule of inference but) N
(it is not complete. It is a limited form of inference. Define the) N
(unit-resolution closure of a theory.) N
() N
(Solving SAT: three approaches:) N
(  -- pure inference) N
(  -- pure search) N
(  -- search + inference) N
() N
() N
(Pure inference:) N
() N
(Compute the resolution closure of theory, and then construct solution) N
(in a backtrack-free manner following an ordering of the variables.) N
() N
(Pure search:) N
() N
(Algoritmo SAT-I: backtracking simple, no early backtrack.) N
(Algoritmo SAT-II: backtracking, early detection of failure or success) N
(  \(if conditioned theory becomes empty, then success. if conditioned) N
(  theory contains empty clause, then failure\), literal choosing.) N
(  Similitud w/ CSPs.) N
() N
(=====================================================================) N
(XIII. SAT.) N
(=====================================================================) N
() N
(Search + inference:) N
() N
(Unit-Propagation\(Delta\):) N
() N
(compute y devuelve la clausura por UP de Delta. Devuelve un par) N
(\(I,Gamma\) donde I es el conjunto de units derivadas por UP, y) N
(Gamma son todas las clausulas no unitarias en la clausura.) N
() N
(Este procedimiento se puede implementar en tiempo lineal utilizando) N
(las estucturas de datos correctas.) N
() N
(1st approach:) N
() N
(Algoritmo DPLL: w/o conditioning by adding units to theory.) N
() N
(DPLL\(Delta\)) N
(-----------) N
(stdin) (Page 21/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(1. If \(I,Gamma\) := Unit-Propagation\(Delta\)) p n
(2. If Gamma = {} then return I) N
(3. If Gamma contains {} then return FAIL) N
(4. L := choose literal in Gamma) N
(5. If M := DPLL\(Gamma union {{L}}\) != FAIL then return M union I) N
(6. If M := DPLL\(Gamma union {{-L}}\) != FAIL then return M union I) N
(7. return FAIL) N
() N
(---------------------------------------------------------------------) N
(Example) N
() N
(Delta = {) N
(  1. {A,B}) N
(  2. {B,C}) N
(  3. {-A,-X,Y}) N
(  4. {-A,X,Z}) N
(  5. {-A,-Y,Z}) N
(  6. {-Z,X,-Z}) N
(  7. {-A,-Y,-Z} }) N
() N
([Show termination tree of DPLL w/ order [A,B,C,X], always setting) N
(true before false]) N
() N
(The theory Delta|A,B,C,X is false because the set of clauses) N
({-X,Y}, {X,Z}, {-Y,Z}, {X,-Z}, {-Y,-Z} is inconsistent. However,) N
(DPLL does not notice this and exhausts the subtree for assignment) N
(A=false.) N
() N
(Implication graphs: Two examples) N
() N
(Graph on literals constructed by adding decisions and unit propagation.) N
() N
(Every cut in the implication graph that separates decision variables) N
(from the contradiction makes up a *conflict set*.) N
(In example 1, we have the conflict sets {A,X}, {A,Y}, {A,Y,Z}.) N
() N
(Conflict set are used to analize reasons of failure, compute) N
(backtrack level, and learn clauses. Since there are multiple) N
(conflict sets, the questions are what is the most useful and) N
(how to use it.) N
() N
(IDEA: Choose cut where all nodes at the current level are on) N
(one side, except for the decision node at the current level) N
(together iwh all other nodes on the other side. Formally,) N
() N
(C\(n\) = {n} if Pa\(n\) = ePa\(n\) = {}) N
(C\(n\) = ePa\(n\) union Union_{m \\in Pa\(n\)} C\(m\) otherwise,) N
() N
(where Pa\(n\) are parents of node n which are set at the same) N
(level as n, and ePa\(n\) are parents of n that are set at ) N
(earlier levels. In the example 1, C\(n\) = {A,X}.) N
() N
(C\(n\) defines a clause {-A,-X} that is *implied* by Delta.) N
(The conflict set also defines the backtrack level:) N
() N
(bl of C\(n\) is the highest level of any literal in C\(n\)) N
(al of C\(n\) is the second highest level of any level in C\(n\)) N
() N
(In principle, it is enough to backtrack to level bl, undoing) N
(all decisions in levels bl,bl+1,bl+2,...  However, SAT solvers) N
(backtrack to level al+1, undoing all the decisions al+1,al+2,...,) N
(*add* the conflict clausle generated by the conflict set, and) N
(run UP. As a result, the conflict clause becomes unit given) N
(a new assignment.) N
() N
(---------------------------------------------------------------------) N
(DPLL w/ clause learning) N
() N
(Need primitives:) N
(stdin) (Page 22/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (11/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (23-24) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(decide\(V=v\) that returns a boolean, but has side effects:) N
() N
(1. Sets variable V to value v) N
(2. Marks variable V as a decision variable and sets its decision) N
(   level to the current decision level) N
(3. Increment current decision level) N
(4. Applies unit resolution, adding any implied variable setting to) N
(   implication graph and assigning implication level. The implication) N
(   level of a variable setting is the maximum of the levels assigned) N
(   to its parents in the implication graph.) N
() N
(If no contradiction is achived by UP, decide\(V=v\) returns true.) N
(Otherwise, decide\(V=v\) returns false, but after constructing a ) N
(conflict-driven clause and computed the assertion level al.) N
() N
(The function undo-decide\(V=v\) erases the decision V=v and all ) N
(implied setting that were derived from it by UP. Updates the) N
(implication graph accordingly and decrement the current decision) N
(level.) N
() N
(at-assertion-level+1\(\) returns true if the current decision level) N
(is equal to al+1, where al was the assertion level computed by) N
(decide\(V=V\).) N
() N
(assert-cdc\(\) adds the conflict driven clause to KB and applied) N
(UP. If no contradiction appears during UP, the function returns) N
(true. Otherwise, returns false after constructing another ) N
(conflict-driven clause and computing a new assertion level.) N
() N
(Boundary conditions for new algorithm:) N
() N
(1. Initially, current decision level is 0) N
(2. Conflict-driven clause may be a unit clause. In such case,) N
(   al is -1 implying a backtrack to level 0 \(undoing all decisions) N
(   made\).) N
(3. Initially, KB has no unit clauses. Can be easily enforced in) N
(   linear time by running UP on the initial KB.) N
() N
(The algorithm DPLL+) N
(-------------------) N
() N
(Let \\V be the set of variables which has not value yet. This is) N
(a global variable. Initially, by 4, it contains all variables) N
(in KB.) N
() N
(DPLL+\(Delta\)) N
(------------) N
(1. If \\V is empty return true) N
(2. Choose variable V and value v) N
(3. If decide\(V=v\) and DPLL+\(\) then) N
(4.     undo-decide\(V=v\)) N
(5.     return true) N
(6. undo-decide\(V=v\)) N
(7. If at-assertion-level+1\(\) then) N
(8.     return assert-cdc\(\) and DPLL+\(\)) N
(9. return false) N
() N
(Example:) N
() N
(Delta = {) N
(  1. {A,B}) N
(  2. {B,C}) N
(  3. {-A,-X,Y}) N
(  4. {-A,X,Z}) N
(  5. {-A,-Y,Z}) N
(  6. {-A,X,-Z}) N
(  7. {-A,-Y,-Z} }) N
() N
(stdin) (Page 23/25) (Jun 05, 14 13:30) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(First: decide\(A=true\), decide\(B=true\), decide\(C=true\), decide\(X=true\)) p n
(Then, UP finds a contradiction and derives the clause {-A,-X}. The) N
(assertion level is 0 and thus backtrack occurs to level 1, undoing) N
(decisions decide\(X=true\), decide\(C=true\), decide\(B=true\). The clause) N
({-A,-X} is added and UP is run. UP finds a new contradiction and) N
(computes the clause {-A}. The assertion level is now -1 and then,) N
(the algorithm backtracks to level 0 undoing all decisions. The) N
(new clause is added and UP is run again. This time, UP set A=false) N
(and B=true, and Delta is satisfied.) N
() N
(=====================================================================) N
(XIV. Resolucion.) N
(=====================================================================) N
() N
(Recordar sintaxis y semantica de LP; nociones de sat, tautologia,) N
(unsat. Regla de inferencia de resolucion. Ejemplo de resoluciones,) N
(y ejemplo de refutacion. Principio de refutacion: probar F -> G) N
(es lo mismo que probar F & -G es UNSAT, y esto ultimo se prueba) N
(buscando una refutacion. Algoritmo general de resolucion: buscar) N
(refutacion. Pseudocodigo. Algoritmo es correct y completo. Termina) N
(cuando no existen nuevas clausulas derivadas cuyo numero maximo) N
(es finito.) N
() N
(Sintaxis de LPO. Semantica \(solo para sentencias\): definicion de) N
(estructura. Definicion intuitiva \(con ejemplo\) de semantica.) N
(Nociones: SAT, TAUT, UNSAT, Consecuencia Logica. ) N
() N
(=====================================================================) N
(XV. Resolucion en LPO.) N
(=====================================================================) N
() N
(Example:) N
() N
(EyAz[ P\(z,y\) <=> -Ex[P\(z,x\) & P\(x,z\)] ]) N
() N
(Clausal form:) N
() N
(C1 = { -P\(z1,a\), -P\(z1,x\), -P\(x,z1\) }) N
(C2 = { P\(z2,f\(z2\)\), P\(z2,a\) }) N
(C3 = { P\(f\(z3\),z3\), P\(z3,a\) }) N
() N
(Ground clauses:) N
() N
(G1 = { -P\(a,a\) } <= C1[x/a,z1/a]) N
(G2 = { P\(a,f\(a\)\), P\(a,a\) } <= C2[z2/a]) N
(G3 = { P\(f\(a\),a\), P\(a,a\) } <= C3[z3/a]) N
(G4 = { -P\(f\(a\),a\), -P\(a,f\(a\)\) } <= C1[z1/f\(a\),x/z]) N
() N
(There is a refutation of this. [Show it]) N
() N
(Thm: Ground resolution is complete for ground clauses) N
(Pf: direct from resolution for prop. logic.) N
() N
(Thm: if a clausal form is inconsistent, there is) N
(an instantiation of them into ground clauses from ) N
(which a refutation can be constructed.) N
() N
(Unification:) N
() N
(Unify\(L,L'\) returns substitution theta such that L[theta] = L'[theta],) N
(and theta is substitution that make least commitments.) N
() N
(MGU:) N
() N
(Unify\(L,L'\) or Unify\(T,T'\)) N
() N
(Fatal disagreements:) N
() N
(  1. C=R\(-\) & C'=P\(-\), or T=f\(-\) & T'=g\(-\)) N
(stdin) (Page 24/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (12/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (25) 13
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  2. T=x and T'!=x and x appears in T'; e.g., T=x ; T'=f\(x\)) p n
() N
(Repairable disagreements:) N
() N
(  1. T=x & T'!=x and x does not appear in T'. Extend unifier w/ x/T') N
() N
() N
(Examples: Unify\(T,T'\) where) N
() N
(1. T=f\(x,f\(x,y\)\) and T'=f\(g\(y\),f\(g\(a\),z\)\) => Theta = [x/g\(a\),y/a,z/a]) N
() N
(Resolution Procedure:) N
() N
(  while Delta does not contain empty clause do) N
(      Choose two clauses C and C' from Delta.) N
(      Let L, L' be two literals in C and C', and theta=Unify\(L,-L'\).) N
(      if theta != Fail then) N
(          Delta := Delta union { Resolvent\(C[theta],C'[theta[\) }) N
(      end if) N
(  end while) N
() N
(Example of resolution proof:) N
() N
(Resolve\(C2,C1\) to find Theta=[z1/a,z2/a,z/a] and C4={ P\(a,f\(a\)\) }) N
(Resolve\(C1,C3\) to find Theta=[z1/a,x/a,z3/a] and C5={ P\(f\(a\),a\) }) N
(Resolve\(C1,C5\) to find Theta=[z1/f\(a\),x/a] and C6={ -P\(a,f\(a\)\) }) N
(Resolve\(C4,C6\) to find Theta=[] and C7={ }) N
() N
(Thm: resolution procedure is guaranteed to terminate if Delta) N
(is inconsistent.) N
() N
(Example:) N
() N
(1. Jack owns a dog. Ex[ Dog\(x\) & Owns\(Jack,x\) ]) N
(2. Every dog owner is an animal lover. Ax[ Ey [ Dog\(y\) & Owns\(x,y\) ] => AnimalLo) N
(ver\(x\) ]) N
(3. No animal lover kills an animal. Ax [ AnimalLover\(x\) => Ay [ Animal\(y\) => -Ki) N
(lls\(x,y\) ] ]) N
(4. Either Jack or Curiosity killed the cat, who is named Tuna.) N
(     Kills\(Jack,Tuna\) or Kills\(Curiosity,Tuna\)) N
(     Cat\(Tuna\)) N
(     Ax[ Cat\(x\) => Animal\(x\) ]) N
(5. Did Curiosity kill the cat?) N
() N
(stdin) (Page 25/25) (Jun 05, 14 13:30) title
border
grestore
(Printed by Blai Bonet) rhead
(stdin) (13/13) (Thursday June 05, 2014) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
